plugins {
    id "cpp"
    id "google-test-test-suite"
    id "edu.wpi.first.GradleRIO" version "2025.1.1-beta-3"
    id "com.gorylenko.gradle-git-properties" version "2.4.1"
}

// Configure the git-properties plugin to output to src/main/deploy
gitProperties {
    gitPropertiesDir = file('src/main/deploy')
    
    // Optimize git properties generation
    extProperty = 'gitProps'
    keys = ['git.branch', 'git.commit.id.abbrev', 'git.commit.time', 'git.commit.id']
    
    // Skip git properties in some cases to improve performance
    failOnNoGitDirectory = false
}

deploy {
    targets {
        roborio(getTargetTypeClass('RoboRIO')) {
            team = project.frc.getTeamNumber()
            debug = project.frc.getDebugOrDefault(false)

            artifacts {
                frcCpp(getArtifactTypeClass('FRCNativeArtifact')) {}

                frcStaticFileDeploy(getArtifactTypeClass('FileTreeArtifact')) {
                    files = project.fileTree('src/main/deploy')
                    directory = '/home/lvuser/deploy'
                    deleteOldFiles = false
                }
            }
        }
    }
}

def deployArtifact = deploy.targets.roborio.artifacts.frcCpp

// Set this to true to enable desktop support.
def includeDesktopSupport = true

// Only build for RoboRIO when explicitly requested (for deployment)
// This speeds up development builds significantly
def buildForRoboRio = project.hasProperty('buildRoboRio') || 
                      gradle.startParameter.taskNames.any { it.contains('deploy') || it.contains('roborio') || it.contains('athena') }

// Set to true to run simulation in debug mode
wpi.cpp.debugSimulation = false
wpi.sim.addGui().defaultEnabled = true
wpi.sim.addDriverstation()

tasks.withType(CppCompile).configureEach {
    dependsOn generateGitProperties
    
    // Optimize C++ compilation - use simple optimization flags
    if (toolChain in Gcc || toolChain in Clang) {
        compilerArgs.addAll(["-O2", "-pipe"])
    }
}

nativeUtils.platformConfigs.named('windowsx86-64').configure {
  it.cppCompiler.args.add("/std:c++2b")
}
nativeUtils.platformConfigs.named('windowsx86').configure {
  it.cppCompiler.args.add("/std:c++2b")
}
nativeUtils.platformConfigs.named('windowsarm64').configure {
  it.cppCompiler.args.add("/std:c++2b")
}
nativeUtils.platformConfigs.named('osxuniversal').configure {
  it.cppCompiler.args.add("-std=c++2b")
}
nativeUtils.platformConfigs.named('linuxx86-64').configure {
  it.cppCompiler.args.add("-std=c++2b")
}
nativeUtils.platformConfigs.named('linuxarm64').configure {
  it.cppCompiler.args.add("-std=c++2b")
}
nativeUtils.platformConfigs.named('linuxathena').configure {
  it.cppCompiler.args.add("-std=c++2b")
}
nativeUtils.platformConfigs.named('linuxsystemcore').configure {
  it.cppCompiler.args.add("-std=c++2b")
}
nativeUtils.platformConfigs.named('linuxarm32').configure {
    it.cppCompiler.args.add("-std=c++2b")
}


model {
    components {
        frcUserProgram(NativeExecutableSpec) {
            // Only add RoboRIO target when needed
            if (buildForRoboRio) {
                targetPlatform wpi.platforms.roborio
            }
            if (includeDesktopSupport) {
                targetPlatform wpi.platforms.desktop
            }

            sources.cpp {
                source {
                    srcDir 'src/main/cpp'
                    include '**/*.cpp', '**/*.cc'
                }
                exportedHeaders {
                    srcDir 'src/main/include'
                }
            }

            // cppCompilerArgs += '-std=c++2b'

            deployArtifact.component = it
            wpi.cpp.enableExternalTasks(it)
            wpi.sim.enable(it)
            wpi.cpp.vendor.cpp(it)
            wpi.cpp.deps.wpilib(it)
        }
    }
    testSuites {
        frcUserProgramTest(GoogleTestTestSuiteSpec) {
            testing $.components.frcUserProgram

            sources.cpp {
                source {
                    srcDir 'src/test/cpp'
                    include '**/*.cpp'
                }
            }

            wpi.cpp.enableExternalTasks(it)
            wpi.cpp.vendor.cpp(it)
            wpi.cpp.deps.wpilib(it)
            wpi.cpp.deps.googleTest(it)
        }
    }
}

// Custom task to format C++ code using clang-format
task format {
    description = 'Format C++ source files using clang-format'
    group = 'formatting'
    
    doLast {
        // Find all C++ source files
        def sourceFiles = []
        fileTree(dir: 'src', includes: ['**/*.cpp', '**/*.cc', '**/*.h']).each { file ->
            sourceFiles << file.absolutePath
        }
        
        if (sourceFiles.isEmpty()) {
            println 'No C++ files found to format'
            return
        }
        
        println "Formatting ${sourceFiles.size()} C++ files..."
        
        // Run clang-format on each file
        sourceFiles.each { filePath ->
            exec {
                commandLine 'clang-format', '-i', '--style=file', filePath
            }
        }
        
        println 'Formatting complete!'
    }
}

// Custom task to build for RoboRio deployment
task buildForDeploy {
    description = 'Build for RoboRio deployment (includes athena platform)'
    group = 'build'
    
    doLast {
        // Execute the build with the buildRoboRio property
        exec {
            workingDir project.projectDir
            commandLine './gradlew', 'clean', 'build', '-PbuildRoboRio=true'
        }
    }
}

// In your build.gradle
// Ensure this block is defined after your plugins block
// (especially after where 'edu.wpi.first.GradleVsCode' and 'edu.wpi.first.GradleRIO' are applied)

// import edu.wpi.first.gradlerio.wpi.WPIArtifact
// import edu.wpi.first.gradlerio.wpi.WPIArtifactType

tasks.register('copyCompileCommands', Copy) {
    // We'll calculate the source directory lazily, only when the task runs
    // Use a Callable or a Closure for the 'from' property
    def finalSourceDirProvider = project.provider {
        def compileCommandsRoot = layout.buildDirectory.dir("TargetedCompileCommands").get().asFile // This .get() is fine here within the provider

        def sourceDirCandidate = null

        def osName = System.getProperty("os.name").toLowerCase()
        def archName = System.getProperty("os.arch").toLowerCase()

        def nativeTargetDir = null
        if (osName.contains("mac")) {
            if (archName.contains("aarch64") || archName.contains("arm")) {
                nativeTargetDir = "osxuniversalrelease"
            } else {
                nativeTargetDir = "osxuniversalrelease"
            }
        } else if (osName.contains("linux")) {
            nativeTargetDir = "linuxx64release"
        } else if (osName.contains("windows")) {
            nativeTargetDir = "windowsx86-64release"
        }

        // --- Prioritized Search for compile_commands.json ---
        // Prioritize native debug
        if (nativeTargetDir != null) {
            def debugNativePath = "${nativeTargetDir.replace('release', 'debug')}"
            def potentialNativeDebugDir = compileCommandsRoot.toPath().resolve(debugNativePath).toFile()
            if (potentialNativeDebugDir.exists() && potentialNativeDebugDir.isDirectory() && new File(potentialNativeDebugDir, "compile_commands.json").exists()) {
                sourceDirCandidate = potentialNativeDebugDir
                println "Found compile_commands.json for native OS (debug): ${sourceDirCandidate}"
            }
        }

        // If no native debug, try native release
        if (sourceDirCandidate == null && nativeTargetDir != null) {
            def potentialNativeReleaseDir = compileCommandsRoot.toPath().resolve(nativeTargetDir).toFile()
            if (potentialNativeReleaseDir.exists() && potentialNativeReleaseDir.isDirectory() && new File(potentialNativeReleaseDir, "compile_commands.json").exists()) {
                sourceDirCandidate = potentialNativeReleaseDir
                println "Found compile_commands.json for native OS (release): ${sourceDirCandidate}"
            }
        }

        // Fallback: RoboRIO debug
        if (sourceDirCandidate == null) {
            def potentialRoboRIODebugDir = compileCommandsRoot.toPath().resolve("roboRIO/debug").toFile()
            if (potentialRoboRIODebugDir.exists() && potentialRoboRIODebugDir.isDirectory() && new File(potentialRoboRIODebugDir, "compile_commands.json").exists()) {
                sourceDirCandidate = potentialRoboRIODebugDir
                println "Found compile_commands.json for roboRIO (debug) as fallback: ${sourceDirCandidate}"
            }
        }

        // Ultimate Fallback: Most recently modified
        if (sourceDirCandidate == null) {
            def allPossibleDirs = []
            // Ensure compileCommandsRoot actually exists before listing directories
            if (compileCommandsRoot.exists() && compileCommandsRoot.isDirectory()) {
                compileCommandsRoot.eachDir { platformDir ->
                    platformDir.eachDir { buildTypeDir ->
                        if (new File(buildTypeDir, "compile_commands.json").exists()) {
                            allPossibleDirs << buildTypeDir
                        }
                    }
                }
                allPossibleDirs.sort { a, b -> b.lastModified() <=> a.lastModified() }

                if (!allPossibleDirs.empty) {
                    sourceDirCandidate = allPossibleDirs.first()
                    println "Falling back to most recently modified compile_commands.json: ${sourceDirCandidate}"
                }
            }
        }

        if (sourceDirCandidate != null) {
            return sourceDirCandidate // Return the directory for 'from'
        } else {
            // If no source directory is found, return an empty file collection
            // Gradle will then just skip the 'from' for this task without error
            println "Warning: copyCompileCommands task will be empty because no suitable compile_commands.json source directory was found."
            return files() // Return empty collection
        }
    }

    // Assign the lazily evaluated source directory
    from finalSourceDirProvider

    include 'compile_commands.json'
    into layout.projectDirectory.asFile
}

// Ensure copyCompileCommands runs after generateCompileCommands
tasks.whenTaskAdded { task ->
    if (task.name == 'generateCompileCommands') {
        task.finalizedBy(tasks.named('copyCompileCommands'))
        tasks.named('generateVsCodeConfig') {
            dependsOn tasks.named('copyCompileCommands')
        }
    }
}
